from ..data.binance_client import BinanceClient
from .indicators import Indicators
import numpy as np
import ccxt.async_support as ccxt
import pandas as pd
from typing import Dict, Optional, Tuple, List
from datetime import datetime
import asyncio
import concurrent.futures
import multiprocessing
from functools import partial
from .advanced_analysis import AdvancedAnalyzer, SignalStrength
import matplotlib.pyplot as plt
import mplfinance as mpf
from io import BytesIO
import ta
from ta.trend import EMAIndicator
from ta.momentum import RSIIndicator
from ta.volatility import BollingerBands
import logging

class MarketAnalyzer:
    def __init__(self, logger=None):
        self.logger = logger or logging.getLogger('MarketAnalyzer')
        self.client = BinanceClient()
        self.indicators = Indicators()
        self.exchange = ccxt.binance()
        self.min_volume = 50000  # Minimum 50k USDT hacim (daha k√º√ß√ºk coinleri de tarayabilmek i√ßin)
        self.min_price = 0.00001
        self.timeframe = '1h'  # 1 saatlik mum
        self.limit = 200  # Son 200 mum
        self.advanced_analyzer = AdvancedAnalyzer()
        
        # Debug i√ßin saya√ßlar
        self.analysis_stats = {
            'total_coins': 0,
            'valid_pairs': 0,
            'price_filtered': 0,
            'volume_filtered': 0,
            'analysis_failed': 0,
            'analysis_success': 0
        }
        
        # Ge√ßerli sembolleri ba≈ülangƒ±√ßta bo≈ü bƒ±rak
        self.valid_symbols = set()
        
        # Kaldƒ±ra√ß limitleri
        self.max_leverage = 20  # Maksimum kaldƒ±ra√ß
        self.risk_levels = {
            'LOW': {'leverage': 2, 'min_score': 40},
            'MEDIUM': {'leverage': 5, 'min_score': 60},
            'HIGH': {'leverage': 10, 'min_score': 80},
            'EXTREME': {'leverage': 20, 'min_score': 90}
        }

        # Trading sinyalleri i√ßin e≈üikler
        self.signal_thresholds = {
            'STRONG_LONG': {'score': 80, 'rsi': 30, 'trend': 'YUKARI'},
            'LONG': {'score': 60, 'rsi': 40, 'trend': 'YUKARI'},
            'STRONG_SHORT': {'score': 80, 'rsi': 70, 'trend': 'A≈ûAƒûI'},
            'SHORT': {'score': 60, 'rsi': 60, 'trend': 'A≈ûAƒûI'},
            'NEUTRAL': {'score': 40, 'rsi': 45}
        }

        # Sinyal seviyeleri
        self.signal_levels = {
            'STRONG_BUY': {'min_score': 80, 'emoji': 'üü¢'},
            'BUY': {'min_score': 65, 'emoji': 'üü°'},
            'NEUTRAL': {'min_score': 45, 'emoji': '‚ö™'},
            'SELL': {'min_score': 35, 'emoji': 'üî¥'},
            'STRONG_SELL': {'min_score': 0, 'emoji': '‚õî'}
        }

    async def initialize(self):
        """
        Asenkron ba≈ülatma i≈ülemleri i√ßin metod
        """
        await self._init_valid_symbols()
        
    async def _init_valid_symbols(self):
        """
        Ge√ßerli sembolleri asenkron olarak y√ºkle
        """
        try:
            exchange_info = await self.client.get_exchange_info()
            self.valid_symbols = [
                symbol['symbol'] for symbol in exchange_info['symbols']
                if symbol['status'] == 'TRADING' and symbol['quoteAsset'] == 'USDT'
            ]
            logging.info(f"Loaded {len(self.valid_symbols)} valid trading symbols")
        except Exception as e:
            logging.error(f"Error initializing valid symbols: {e}")
            self.valid_symbols = []

    async def analyze_market(self, ticker_data: list, interval: str = '4h') -> list:
        """T√ºm market analizi"""
        try:
            opportunities = []
            
            # Saya√ßlarƒ± sƒ±fƒ±rla
            self.analysis_stats = {key: 0 for key in self.analysis_stats}
            self.analysis_stats['total_coins'] = len(ticker_data)
            
            self.logger.info(f"üîç Toplam {len(ticker_data)} coin taranƒ±yor...")
            
            # Ticker verilerini al
            try:
                if not ticker_data:
                    # Eƒüer ticker_data bo≈üsa, exchange'den al
                    ticker_data = await self.exchange.fetch_tickers()
                    ticker_data = [
                        {'symbol': symbol, 'lastPrice': ticker['last'], 'quoteVolume': ticker['quoteVolume']}
                        for symbol, ticker in ticker_data.items()
                    ]
            except Exception as e:
                self.logger.error(f"Ticker verisi alma hatasƒ±: {str(e)}")
                return []

            for ticker in ticker_data:
                try:
                    symbol = ticker['symbol']
                    
                    # Blacklist kontrol√º
                    # Sadece USDT √ßiftlerini analiz et
                    if not symbol.endswith('USDT'):
                        continue
                        
                    # Blacklist kar≈üƒ±la≈ütƒ±rma
                    blacklist = [
                        "EURUSDT", "GBPUSDT", "TRYUSDT", "USDTBRL", "USDTRUB", "AUDUSDT", "CADUSDT",
                        "JPYUSDT", "CNHUSDT", "CHFUSDT", "AUDUSDT", "NZDSUSDT", "RUBUSDT", "BUSDUSDT",
                        "TUSDUSDT", "USDCUSDT", "DAIUSDT", "FDUSDUSDT", "PYUSDUSDT", "BRLBIDR", "BRLRUB",
                        "USDTBKRW", "EURUSDC", "IDRTUSDT", "UAHUSDT", "VAIUSDT", "NGNUSDT", "BIDRUSDT", "BVNDUSDT", "BKRWUSDT"
                    ]
                    
                    # Kaldƒ±ra√ßlƒ± tokenlar i√ßin pattern'ler
                    blacklist_patterns = ["UP", "DOWN", "BULL", "BEAR"]
                    
                    # Blacklist ve pattern kontrolleri
                    if symbol in blacklist:
                        self.logger.debug(f"üö´ {symbol} blacklist'te olduƒüu i√ßin atlandƒ±")
                        continue
                        
                    if any(pattern in symbol for pattern in blacklist_patterns):
                        self.logger.debug(f"üö´ {symbol} kaldƒ±ra√ßlƒ± token olduƒüu i√ßin atlandƒ± ({[p for p in blacklist_patterns if p in symbol]})")
                        continue
                        
                    self.analysis_stats['valid_pairs'] += 1
                    
                    # Minimum fiyat kontrol√º
                    current_price = float(ticker['lastPrice'])
                    if current_price < self.min_price:
                        self.analysis_stats['price_filtered'] += 1
                        self.logger.debug(f"üí∞ {symbol} d√º≈ü√ºk fiyat nedeniyle atlandƒ±: {current_price}")
                        continue
                        
                    # Minimum hacim kontrol√º - daha d√º≈ü√ºk hacim e≈üiƒüi kullan
                    current_volume = float(ticker['quoteVolume'])
                    if current_volume < self.min_volume:  # 50k USDT'ye d√º≈ü√ºr√ºld√º
                        self.analysis_stats['volume_filtered'] += 1
                        self.logger.debug(f"üìä {symbol} d√º≈ü√ºk hacim nedeniyle atlandƒ±: {current_volume:.2f} USDT < {self.min_volume} USDT")
                        continue

                    # OHLCV verilerini al
                    try:
                        ohlcv = await self.exchange.fetch_ohlcv(symbol, interval, limit=100)
                        if not ohlcv or len(ohlcv) < 100:
                            self.analysis_stats['analysis_failed'] += 1
                            self.logger.debug(f"üìà {symbol} yetersiz OHLCV verisi")
                            continue
                            
                        self.logger.debug(f"‚úÖ {symbol} analiz ediliyor...")
                        
                        # Verileri numpy dizilerine d√∂n√º≈üt√ºr
                        closes = np.array([float(candle[4]) for candle in ohlcv])
                        volumes = np.array([float(candle[5]) for candle in ohlcv])
                        
                        # Teknik indikat√∂rleri hesapla
                        rsi = self._calculate_rsi(closes)
                        macd, signal, hist = self._calculate_macd(closes)
                        bb_upper, bb_middle, bb_lower = self._calculate_bollinger_bands(closes)
                        ema20 = self._calculate_ema(closes, 20)
                        ema50 = self._calculate_ema(closes, 50)
                        
                        # Hacim analizi
                        avg_volume = np.mean(volumes[-20:])
                        volume_surge = current_volume > (avg_volume * 1.2)  # Hacim artƒ±≈ü e≈üiƒüini d√º≈ü√ºrd√ºk
                        
                        # Trend analizi
                        trend = "YUKARI" if ema20[-1] > ema50[-1] else "A≈ûAƒûI"
                        
                        # Fƒ±rsat puanƒ± hesapla
                        opportunity_score = self._calculate_opportunity_score(
                            rsi[-1],
                            hist[-1],
                            volume_surge,
                            trend,
                            current_volume,
                            avg_volume
                        )
                        
                        # Fƒ±rsat e≈üiƒüini d√º≈ü√ºrd√ºk
                        if opportunity_score >= 40:  # 50'den 40'a d√º≈ü√ºrd√ºk
                            position_rec = self._analyze_position_recommendation(
                                rsi[-1], hist[-1], ema20[-1], ema50[-1],
                                bb_upper, bb_lower, current_price, opportunity_score, volume_surge
                            )
                            
                            # Sinyal belirle
                            signal = self._determine_signal(opportunity_score, rsi[-1], trend)
                            
                            opportunity = {
                                'symbol': symbol,
                                'price': current_price,
                                'volume': current_volume,
                                'rsi': float(rsi[-1]),
                                'macd': float(hist[-1]),
                                'trend': trend,
                                'volume_surge': volume_surge,
                                'opportunity_score': float(opportunity_score),
                                'signal': signal,
                                'position_recommendation': position_rec['position'],
                                'position_confidence': position_rec['confidence'],
                                'recommended_leverage': position_rec['leverage'],
                                'risk_level': position_rec['risk_level'],
                                'analysis_reasons': position_rec['reasons'],
                                'score': position_rec['score'],
                                'ema20': float(ema20[-1]),
                                'ema50': float(ema50[-1]),
                                'bb_upper': float(bb_upper),
                                'bb_middle': float(bb_middle),
                                'bb_lower': float(bb_lower)
                            }
                            
                            opportunities.append(opportunity)
                            self.analysis_stats['analysis_success'] += 1
                            self.logger.debug(f"üíé {symbol} fƒ±rsat bulundu! Skor: {opportunity_score:.1f}")
                        
                    except Exception as e:
                        self.analysis_stats['analysis_failed'] += 1
                        self.logger.debug(f"‚ùå {symbol} analiz hatasƒ±: {str(e)}")
                        continue

                except Exception as e:
                    self.analysis_stats['analysis_failed'] += 1
                    self.logger.debug(f"‚ùå {symbol} i≈üleme hatasƒ±: {str(e)}")
                    continue
            
            # Analiz istatistiklerini logla
            self.logger.info("\nüìä TARAMA ƒ∞STATƒ∞STƒ∞KLERƒ∞:")
            self.logger.info(f"üìå Toplam Coin: {self.analysis_stats['total_coins']}")
            self.logger.info(f"‚úÖ Ge√ßerli USDT √áiftleri: {self.analysis_stats['valid_pairs']}")
            self.logger.info(f"üí∞ Fiyat Filtresi: {self.analysis_stats['price_filtered']}")
            self.logger.info(f"üìä Hacim Filtresi: {self.analysis_stats['volume_filtered']}")
            self.logger.info(f"‚ú® Ba≈üarƒ±lƒ± Analiz: {self.analysis_stats['analysis_success']}")
            self.logger.info(f"‚ùå Ba≈üarƒ±sƒ±z Analiz: {self.analysis_stats['analysis_failed']}")
            
            # Fƒ±rsatlarƒ± puana g√∂re sƒ±rala
            opportunities.sort(key=lambda x: x['opportunity_score'], reverse=True)
            
            if opportunities:
                self.logger.info(f"üéØ Bulunan Fƒ±rsat Sayƒ±sƒ±: {len(opportunities)}")
            else:
                self.logger.info("‚ùå Fƒ±rsat bulunamadƒ±")
            
            return opportunities[:10]  # En iyi 10 fƒ±rsatƒ± d√∂nd√ºr
            
        except Exception as e:
            self.logger.error(f"Market analysis error: {str(e)}")
            return []
        finally:
            try:
                await self.exchange.close()
            except:
                pass

    def _calculate_rsi(self, prices: np.ndarray, period: int = 14) -> np.ndarray:
        """RSI hesapla"""
        deltas = np.diff(prices)
        seed = deltas[:period+1]
        up = seed[seed >= 0].sum()/period
        down = -seed[seed < 0].sum()/period
        rs = up/down if down != 0 else 0
        rsi = np.zeros_like(prices)
        rsi[:period] = 100. - 100./(1.+rs)

        for i in range(period, len(prices)):
            delta = deltas[i-1]
            if delta > 0:
                upval = delta
                downval = 0.
            else:
                upval = 0.
                downval = -delta

            up = (up*(period-1) + upval)/period
            down = (down*(period-1) + downval)/period
            rs = up/down if down != 0 else 0
            rsi[i] = 100. - 100./(1.+rs)

        return rsi

    def _calculate_macd(self, prices: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """MACD hesapla"""
        exp1 = pd.Series(prices).ewm(span=12, adjust=False).mean()
        exp2 = pd.Series(prices).ewm(span=26, adjust=False).mean()
        macd = exp1 - exp2
        signal = macd.ewm(span=9, adjust=False).mean()
        hist = macd - signal
        return macd.values, signal.values, hist.values

    def _calculate_bollinger_bands(self, prices: np.ndarray, period: int = 20) -> Tuple[float, float, float]:
        """Bollinger Bands hesapla"""
        sma = np.mean(prices[-period:])
        std = np.std(prices[-period:])
        upper = sma + (std * 2)
        lower = sma - (std * 2)
        return upper, sma, lower

    def _calculate_ema(self, prices: np.ndarray, period: int) -> np.ndarray:
        """EMA hesapla"""
        return pd.Series(prices).ewm(span=period, adjust=False).mean().values

    def _calculate_opportunity_score(self, rsi: float, macd: float, 
                                   volume_surge: bool, trend: str,
                                   current_volume: float, avg_volume: float) -> float:
        """Fƒ±rsat puanƒ± hesapla (0-100)"""
        score = 0
        
        # RSI bazlƒ± puan (0-30)
        if rsi < 30:  # A≈üƒ±rƒ± satƒ±m
            score += 30
        elif rsi > 70:  # A≈üƒ±rƒ± alƒ±m
            score += 10
        else:
            score += 20
            
        # MACD bazlƒ± puan (0-20)
        if macd > 0:
            score += 20
        elif macd < 0:
            score += 5
        
        # Hacim bazlƒ± puan (0-30)
        if volume_surge:
            score += 30
        else:
            volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1
            score += min(30, volume_ratio * 15)
            
        # Trend bazlƒ± puan (0-20)
        if trend == "YUKARI":
            score += 20
        else:
            score += 10  # D√º≈ü√º≈ü trendinde de puan ver
            
        return min(100, score)

    def _format_position_signal(self, position_type: str) -> str:
        """Pozisyon sinyalini formatla"""
        signals = {
            'STRONG_LONG': "üíö G√ú√áL√ú LONG",
            'LONG': "üíö LONG",
            'STRONG_SHORT': "‚ù§Ô∏è G√ú√áL√ú SHORT",
            'SHORT': "‚ù§Ô∏è SHORT",
            'NEUTRAL': "‚ö™ N√ñTR"
        }
        return signals.get(position_type, "‚ö™ N√ñTR")

    def _determine_signal(self, score: float, rsi: float, trend: str) -> str:
        """Sinyal belirle"""
        # RSI bazlƒ± ek kontroller
        rsi_extreme = False
        if rsi <= 30 or rsi >= 70:
            rsi_extreme = True

        # Trend bazlƒ± ek kontroller
        trend_strong = trend in ["YUKARI", "A≈ûAƒûI"]

        # Sinyal seviyesini belirle
        if score >= self.signal_levels['STRONG_BUY']['min_score'] and (rsi_extreme or trend_strong):
            return f"{self.signal_levels['STRONG_BUY']['emoji']} G√ú√áL√ú AL"
        elif score >= self.signal_levels['BUY']['min_score']:
            return f"{self.signal_levels['BUY']['emoji']} AL"
        elif score >= self.signal_levels['NEUTRAL']['min_score']:
            return f"{self.signal_levels['NEUTRAL']['emoji']} N√ñTR"
        elif score >= self.signal_levels['SELL']['min_score']:
            return f"{self.signal_levels['SELL']['emoji']} SAT"
        else:
            return f"{self.signal_levels['STRONG_SELL']['emoji']} G√ú√áL√ú SAT"

    async def analyze_single_coin(self, symbol: str) -> Optional[Dict]:
        """Tek bir coin i√ßin analiz yap"""
        try:
            # API √ßaƒürƒ±sƒ±nƒ± kaldƒ±r veya devre dƒ±≈üƒ± bƒ±rak
            if not self.valid_symbols:
                await self._init_valid_symbols()

            if symbol not in self.valid_symbols:
                self.logger.error(f"Invalid symbol: {symbol}")
                return None

            self.logger.debug(f"Analyzing {symbol}...")
            
            # OHLCV verilerini al - timeframe yerine interval kullan
            ohlcv = await self.exchange.fetch_ohlcv(symbol, interval='1h', limit=100)
            if not ohlcv or len(ohlcv) < 100:
                self.logger.error(f"Insufficient OHLCV data for {symbol}")
                return None
                
            # Verileri numpy dizilerine d√∂n√º≈üt√ºr
            closes = np.array([float(candle[4]) for candle in ohlcv])
            volumes = np.array([float(candle[5]) for candle in ohlcv])
            
            # Teknik indikat√∂rleri hesapla
            rsi = self._calculate_rsi(closes)
            macd, signal, hist = self._calculate_macd(closes)
            bb_upper, bb_middle, bb_lower = self._calculate_bollinger_bands(closes)
            
            # Hacim analizi
            avg_volume = np.mean(volumes[-20:])
            current_volume = float(ohlcv[-1][5]) if len(ohlcv) > 0 else 0
            volume_surge = current_volume > (avg_volume * 1.5)
            
            # Trend analizi
            ema20 = self._calculate_ema(closes, 20)
            ema50 = self._calculate_ema(closes, 50)
            trend = "YUKARI" if ema20[-1] > ema50[-1] else "A≈ûAƒûI"
            
            # Fƒ±rsat puanƒ± hesapla
            opportunity_score = self._calculate_opportunity_score(
                rsi[-1],
                hist[-1],
                volume_surge,
                trend,
                current_volume,
                avg_volume
            )
            
            # Pozisyon √∂nerisi al
            position_rec = self._analyze_position_recommendation(
                rsi[-1], hist[-1], ema20[-1], ema50[-1],
                bb_upper, bb_lower, closes[-1], opportunity_score, volume_surge
            )
            
            # Sinyal belirle
            signal = self._determine_signal(opportunity_score, rsi[-1], trend)
            
            # Pozisyon y√∂n√º analizi ekle
            position_analysis = self.analyze_position_direction(pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume']))
            
            return {
                'symbol': symbol,
                'price': closes[-1],
                'volume': current_volume,
                'rsi': float(rsi[-1]),
                'macd': float(hist[-1]),
                'trend': trend,
                'volume_surge': volume_surge,
                'opportunity_score': float(opportunity_score),
                'signal': signal,
                'position_recommendation': position_rec['position'],
                'position_confidence': position_rec['confidence'],
                'recommended_leverage': position_rec['leverage'],
                'risk_level': position_rec['risk_level'],
                'analysis_reasons': position_rec['reasons'],
                'score': position_rec['score'],
                'ema20': float(ema20[-1]),
                'ema50': float(ema50[-1]),
                'bb_upper': float(bb_upper),
                'bb_middle': float(bb_middle),
                'bb_lower': float(bb_lower),
                'position': position_analysis['direction'],
                'confidence': position_analysis['confidence'],
                'current_price': position_analysis['current_price'],
                'long_position': position_analysis['long_position'],
                'short_position': position_analysis['short_position'],
                'signals': position_analysis['signals']
            }
            
        except Exception as e:
            self.logger.error(f"Single coin analysis error ({symbol}): {str(e)}")
            return None
        finally:
            try:
                await self.exchange.close()
            except:
                pass

    def _calculate_atr(self, prices: np.ndarray, period: int = 14) -> float:
        """ATR (Average True Range) hesapla"""
        high = prices
        low = prices
        close = prices
        
        tr1 = np.abs(high[1:] - low[1:])
        tr2 = np.abs(high[1:] - close[:-1])
        tr3 = np.abs(low[1:] - close[:-1])
        
        tr = np.maximum(np.maximum(tr1, tr2), tr3)
        atr = np.mean(tr[-period:])
        
        return float(atr)

    def _analyze_position_recommendation(self, 
                                  rsi: float, 
                                  macd: float, 
                                  ema20: float,
                                  ema50: float,
                                  bb_upper: float,
                                  bb_lower: float,
                                  current_price: float,
                                  opportunity_score: float,
                                  volume_surge: bool) -> dict:
        """Pozisyon √∂nerisi analizi - Geli≈ütirilmi≈ü versiyon"""
        long_points = 0
        short_points = 0
        reasons = []
        
        # RSI Analizi - Daha net ayƒ±rƒ±m
        if rsi < 30:
            long_points += 4  # Arttƒ±rƒ±ldƒ±
            reasons.append("üíö RSI a≈üƒ±rƒ± satƒ±m b√∂lgesinde (LONG)")
        elif rsi > 70:
            short_points += 4  # Arttƒ±rƒ±ldƒ±
            reasons.append("‚ù§Ô∏è RSI a≈üƒ±rƒ± alƒ±m b√∂lgesinde (SHORT)")
        elif rsi < 40:
            long_points += 2  # Daha y√ºksek aralƒ±k
            reasons.append("üíö RSI satƒ±m b√∂lgesine yakƒ±n (LONG)")
        elif rsi > 60:
            short_points += 2  # Daha y√ºksek aralƒ±k
            reasons.append("‚ù§Ô∏è RSI alƒ±m b√∂lgesine yakƒ±n (SHORT)")
        # 40-60 aralƒ±ƒüƒ±nda hi√ßbir puan verme
            
        # MACD Analizi - Daha g√º√ßl√º etki
        if macd > 0 and macd > abs(macd) * 0.05:  # E≈üik arttƒ±rƒ±ldƒ±
            long_points += 3  # Arttƒ±rƒ±ldƒ±
            reasons.append("üíö MACD g√º√ßl√º pozitif sinyal (LONG)")
        elif macd < 0 and abs(macd) > abs(macd) * 0.05:  # E≈üik arttƒ±rƒ±ldƒ±
            short_points += 3
            reasons.append("‚ù§Ô∏è MACD g√º√ßl√º negatif sinyal (SHORT)")
            
        # EMA Trend Analizi - Daha net trend ayrƒ±mƒ±
        ema_diff_percent = (ema20 - ema50) / ema50 * 100
        
        if ema_diff_percent > 1:  # %1'den fazla fark
            long_points += 4  # Arttƒ±rƒ±ldƒ±
            reasons.append("üíö G√º√ßl√º y√ºkseli≈ü trendi - EMA20 > EMA50 (LONG)")
        elif ema_diff_percent > 0.2:  # %0.2'den fazla fark
            long_points += 2  # Arttƒ±rƒ±ldƒ±
            reasons.append("üíö Y√ºkseli≈ü trendi ba≈ülangƒ±cƒ± (LONG)")
        elif ema_diff_percent < -1:  # %1'den fazla fark
            short_points += 4  # Arttƒ±rƒ±ldƒ±
            reasons.append("‚ù§Ô∏è G√º√ßl√º d√º≈ü√º≈ü trendi - EMA20 < EMA50 (SHORT)")
        elif ema_diff_percent < -0.2:  # %0.2'den fazla fark
            short_points += 2  # Arttƒ±rƒ±ldƒ±
            reasons.append("‚ù§Ô∏è D√º≈ü√º≈ü trendi ba≈ülangƒ±cƒ± (SHORT)")
        
        # Bollinger Bands Analizi - Net bir ayƒ±rƒ±m i√ßin
        if current_price > 0 and bb_upper > bb_lower:  # Sƒ±fƒ±r kontrol√º
            bb_position = (current_price - bb_lower) / (bb_upper - bb_lower) * 100
            if bb_position < 10:  # Daha kesin sƒ±nƒ±rlar
                long_points += 5  # Arttƒ±rƒ±ldƒ±
                reasons.append("üíö Fiyat BB alt bandƒ±nƒ±n altƒ±nda (G√ú√áL√ú LONG)")
            elif bb_position < 20:
                long_points += 3
                reasons.append("üíö Fiyat BB alt bandƒ±na yakƒ±n (LONG)")
            elif bb_position > 90:  # Daha kesin sƒ±nƒ±rlar
                short_points += 5  # Arttƒ±rƒ±ldƒ±
                reasons.append("‚ù§Ô∏è Fiyat BB √ºst bandƒ±nƒ±n √ºst√ºnde (G√ú√áL√ú SHORT)")
            elif bb_position > 80:
                short_points += 3
                reasons.append("‚ù§Ô∏è Fiyat BB √ºst bandƒ±na yakƒ±n (SHORT)")
        
        # Hacim analizi - Daha net yorumla
        if volume_surge:
            if long_points > short_points * 1.5:  # B√ºy√ºk fark varsa hacim sinyali g√º√ßlendir
                long_points += 3  # Arttƒ±rƒ±ldƒ±
                reasons.append("üíö Y√ºksek hacimle y√ºkseli≈ü (LONG)")
            elif short_points > long_points * 1.5:  # B√ºy√ºk fark varsa hacim sinyali g√º√ßlendir
                short_points += 3  # Arttƒ±rƒ±ldƒ±
                reasons.append("‚ù§Ô∏è Y√ºksek hacimle d√º≈ü√º≈ü (SHORT)")
        
        # Eklenen emniyet kontrol√º - minimum puan farkƒ±
        if abs(long_points - short_points) < 2:
            # Puanlar √ßok yakƒ±nsa, EMA trendine g√∂re karar ver
            if ema20 > ema50:
                long_points += 1
            else:
                short_points += 1
        
        # Pozisyon t√ºr√ºn√º ve g√ºc√ºn√º belirle - daha net ayƒ±rƒ±m
        if long_points > short_points + 2:  # Minimum fark ≈üartƒ±
            if long_points >= 8:  # Y√ºkseltildi
                position_type = "STRONG_LONG"
                confidence = 3
            else:
                position_type = "LONG"
                confidence = 2
        elif short_points > long_points + 2:  # Minimum fark ≈üartƒ±
            if short_points >= 8:  # Y√ºkseltildi
                position_type = "STRONG_SHORT"
                confidence = 3
            else:
                position_type = "SHORT"
                confidence = 2
        else:
            position_type = "NEUTRAL"
            confidence = 1
        
        # Kaldƒ±ra√ß √∂nerisi
        leverage = self._recommend_leverage(opportunity_score, position_type, confidence)
        
        # Debug i√ßin ekstra bilgi ekle
        debug_info = {
            'long_points': long_points,
            'short_points': short_points,
            'ema_diff_percent': ema_diff_percent
        }
        
        return {
            'position': position_type,
            'confidence': confidence,
            'leverage': leverage,
            'reasons': reasons,
            'risk_level': self._get_risk_level(leverage),
            'score': opportunity_score,
            'debug': debug_info  # Analiz i√ßin debug bilgisi
        }

    def _recommend_leverage(self, opportunity_score: float, position_type: str, confidence: int) -> int:
        """Kaldƒ±ra√ß √∂nerisi hesapla"""
        # Base kaldƒ±ra√ß puanƒ±nƒ± hesapla
        if opportunity_score >= 90:
            base_leverage = self.risk_levels['EXTREME']['leverage']
        elif opportunity_score >= 80:
            base_leverage = self.risk_levels['HIGH']['leverage']
        elif opportunity_score >= 60:
            base_leverage = self.risk_levels['MEDIUM']['leverage']
        else:
            base_leverage = self.risk_levels['LOW']['leverage']
        
        # Pozisyon t√ºr√ºne g√∂re ayarla
        if position_type.startswith('STRONG'):
            leverage = base_leverage
        elif position_type == 'NEUTRAL':
            leverage = max(2, base_leverage - 4)
        else:
            leverage = max(2, base_leverage - 2)
        
        # G√ºven skoruna g√∂re ayarla
        leverage = leverage * confidence // 3
        
        return min(leverage, self.max_leverage)

    def _get_risk_level(self, leverage: int) -> str:
        """Kaldƒ±ra√ß seviyesine g√∂re risk seviyesini belirle"""
        if leverage >= 15:
            return "‚ö†Ô∏è A≈ûIRI Rƒ∞SKLƒ∞"
        elif leverage >= 10:
            return "üî¥ Y√úKSEK Rƒ∞SK"
        elif leverage >= 5:
            return "üü° ORTA Rƒ∞SK"
        else:
            return "üü¢ D√ú≈û√úK Rƒ∞SK"

    def _format_position_message(self, analysis: dict) -> str:
        """Pozisyon √∂nerisi mesajƒ±nƒ± formatla"""
        position = analysis['position_recommendation']
        leverage = analysis['recommended_leverage']
        risk_level = analysis['risk_level']
        
        message = (
            f"üìä POZƒ∞SYON √ñNERƒ∞Sƒ∞:\n"
            f"{'üü¢ LONG' if position == 'LONG' else 'üî¥ SHORT'} x{leverage}\n"
            f"Risk Seviyesi: {risk_level}\n\n"
            f"üìù Analiz Nedenleri:\n"
        )
        
        for reason in analysis['analysis_reasons']:
            message += f"‚Ä¢ {reason}\n"
            
        return message 

    def analyze_volume_profile(self, df: pd.DataFrame) -> Dict:
        """Hacim profili analizi"""
        try:
            recent_volume = df['volume'].tail(20).mean()
            volume_sma = df['volume'].rolling(window=20).mean()
            
            volume_strength = 'WEAK'
            if recent_volume > volume_sma.mean() * 2:
                volume_strength = 'VERY_STRONG'
            elif recent_volume > volume_sma.mean() * 1.5:
                volume_strength = 'STRONG'
            elif recent_volume > volume_sma.mean() * 1.2:
                volume_strength = 'MODERATE'
                
            return {
                'strength': volume_strength,
                'recent_volume': float(recent_volume),
                'average_volume': float(volume_sma.mean())
            }
        except Exception as e:
            self.logger.error(f"Hacim profili analiz hatasƒ±: {e}")
            return {'strength': 'WEAK', 'recent_volume': 0, 'average_volume': 0}

    def analyze_trend_strength(self, df: pd.DataFrame) -> float:
        """Trend g√ºc√º analizi"""
        try:
            # EMA hesapla
            ema20 = df['close'].ewm(span=20, adjust=False).mean()
            ema50 = df['close'].ewm(span=50, adjust=False).mean()
            ema200 = df['close'].ewm(span=200, adjust=False).mean()
            
            # Trend y√∂n√º ve g√ºc√º
            trend_score = 0.0
            
            # Kƒ±sa vadeli trend
            if ema20.iloc[-1] > ema50.iloc[-1]:
                trend_score += 0.4
            
            # Orta vadeli trend
            if ema50.iloc[-1] > ema200.iloc[-1]:
                trend_score += 0.3
            
            # Momentum
            roc = (df['close'].iloc[-1] - df['close'].iloc[-20]) / df['close'].iloc[-20] * 100
            if roc > 0:
                trend_score += 0.3
                
            return float(trend_score)
            
        except Exception as e:
            self.logger.error(f"Trend g√ºc√º analiz hatasƒ±: {e}")
            return 0.0

    def analyze_momentum(self, df: pd.DataFrame) -> Dict:
        """Momentum analizi"""
        try:
            # RSI
            rsi = self.calculate_rsi(df)
            
            # MACD
            macd = self.calculate_macd(df['close'].to_numpy())
            
            # Momentum g√ºc√º
            momentum_strength = 'WEAK'
            if rsi > 70 and macd[0][-1] > 0:
                momentum_strength = 'VERY_STRONG'
            elif rsi > 60 and macd[0][-1] > 0:
                momentum_strength = 'STRONG'
            elif rsi > 50 and macd[0][-1] > 0:
                momentum_strength = 'MODERATE'
                
            return {
                'strength': momentum_strength,
                'rsi': float(rsi),
                'macd': float(macd[0][-1])
            }
        except Exception as e:
            self.logger.error(f"Momentum analiz hatasƒ±: {e}")
            return {'strength': 'WEAK', 'rsi': 50, 'macd': 0}

    def analyze_liquidity(self, df: pd.DataFrame) -> Dict:
        """Likidite analizi"""
        try:
            # Hacim bazlƒ± likidite skoru
            volume_mean = df['volume'].mean()
            recent_volume = df['volume'].tail(20).mean()
            liquidity_score = min(1.0, recent_volume / volume_mean)
            
            return {
                'score': float(liquidity_score),
                'average_volume': float(volume_mean),
                'recent_volume': float(recent_volume)
            }
        except Exception as e:
            self.logger.error(f"Likidite analiz hatasƒ±: {e}")
            return {'score': 0.0, 'average_volume': 0, 'recent_volume': 0}

    def calculate_volatility(self, df: pd.DataFrame) -> float:
        """Volatilite hesaplama"""
        try:
            returns = df['close'].pct_change()
            return float(returns.std())
        except Exception as e:
            self.logger.error(f"Volatilite hesaplama hatasƒ±: {e}")
            return 0.0

    def calculate_atr(self, df: pd.DataFrame, period: int = 14) -> float:
        """ATR (Average True Range) hesaplama"""
        try:
            high = df['high']
            low = df['low']
            close = df['close']
            
            tr1 = high - low
            tr2 = abs(high - close.shift())
            tr3 = abs(low - close.shift())
            
            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
            atr = tr.rolling(window=period).mean()
            
            return float(atr.iloc[-1])
        except Exception as e:
            self.logger.error(f"ATR hesaplama hatasƒ±: {e}")
            return 0.0

    async def validate_advanced_signal(self, symbol: str, timeframe: str) -> Dict:
        """Geli≈ümi≈ü sinyal doƒürulama"""
        try:
            # OHLCV verilerini al
            ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=self.limit)
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            score = 0
            required_score = {'15m': 12, '4h': 10}
            
            # Teknik analiz skoru
            analysis = await self.analyze_single_coin(symbol)
            if analysis and analysis.get('opportunity_score', 0) > 80:
                score += 3
            elif analysis and analysis.get('opportunity_score', 0) > 70:
                score += 2
            
            # Hacim analizi
            volume_profile = self.analyze_volume_profile(df)
            if volume_profile['strength'] == 'VERY_STRONG':
                score += 3
            elif volume_profile['strength'] == 'STRONG':
                score += 2
            
            # Trend g√ºc√º
            trend_strength = self.analyze_trend_strength(df)
            if trend_strength > 0.8:
                score += 3
            elif trend_strength > 0.6:
                score += 2
            
            # Momentum
            momentum = self.analyze_momentum(df)
            if momentum['strength'] == 'VERY_STRONG':
                score += 3
            elif momentum['strength'] == 'STRONG':
                score += 2
            
            # Likidite
            liquidity = self.analyze_liquidity(df)
            if liquidity['score'] > 0.8:
                score += 2
            elif liquidity['score'] > 0.6:
                score += 1
            
            return {
                'score': score,
                'required_score': required_score.get(timeframe, 10),
                'is_valid': score >= required_score.get(timeframe, 10),
                'confidence': score / 15 * 100
            }
            
        except Exception as e:
            self.logger.error(f"Geli≈ümi≈ü sinyal doƒürulama hatasƒ±: {e}")
            return {'is_valid': False, 'confidence': 0}

    def calculate_advanced_risk_management(self, df: pd.DataFrame, entry_price: float, timeframe: str) -> Optional[Dict]:
        """Geli≈ümi≈ü risk y√∂netimi"""
        try:
            volatility = self.calculate_volatility(df)
            atr = self.calculate_atr(df)
            
            risk_factors = {
                '15m': {
                    'sl_mult': 1.5 + (volatility * 0.5),
                    'tp_mult': 3.0 + (volatility * 1.0),
                    'trailing_start': 1.5,
                    'partial_exit': [
                        {'percentage': 30, 'at_profit': 1.0},
                        {'percentage': 40, 'at_profit': 2.0},
                        {'percentage': 30, 'at_profit': 3.0}
                    ]
                },
                '4h': {
                    'sl_mult': 2.0 + (volatility * 0.7),
                    'tp_mult': 4.0 + (volatility * 1.5),
                    'trailing_start': 2.0,
                    'partial_exit': [
                        {'percentage': 20, 'at_profit': 1.5},
                        {'percentage': 30, 'at_profit': 3.0},
                        {'percentage': 30, 'at_profit': 4.5},
                        {'percentage': 20, 'at_profit': 6.0}
                    ]
                }
            }
            
            factors = risk_factors.get(timeframe, risk_factors['4h'])
            
            stop_loss = entry_price - (atr * factors['sl_mult'])
            take_profit = entry_price + (atr * factors['tp_mult'])
            trailing_activation = entry_price * (1 + factors['trailing_start'] / 100)
            
            rr_ratio = (take_profit - entry_price) / (entry_price - stop_loss)
            if rr_ratio < 2:
                return None
                
            return {
                'stop_loss': float(stop_loss),
                'take_profit': float(take_profit),
                'trailing_activation': float(trailing_activation),
                'trailing_step': float(atr * 0.3),
                'partial_exits': factors['partial_exit'],
                'risk_reward_ratio': float(rr_ratio)
            }
            
        except Exception as e:
            self.logger.error(f"Risk y√∂netimi hesaplama hatasƒ±: {e}")
            return None 

    def analyze_position_direction(self, df: pd.DataFrame) -> Dict:
        """Pozisyon y√∂n√º analizi"""
        try:
            # Son kapanƒ±≈ü fiyatƒ±
            current_price = float(df['close'].iloc[-1])
            
            # EMA hesapla
            ema20 = df['close'].ewm(span=20, adjust=False).mean()
            ema50 = df['close'].ewm(span=50, adjust=False).mean()
            
            # RSI
            rsi = self.calculate_rsi(df)
            
            # MACD
            macd, signal, hist = self.calculate_macd(df['close'].to_numpy())
            
            # Bollinger Bands
            bb_upper, bb_middle, bb_lower = self.calculate_bollinger_bands(df['close'].to_numpy())
            
            # Pozisyon y√∂n√º belirleme
            long_signals = 0
            short_signals = 0
            
            # EMA bazlƒ± sinyal
            if current_price > ema20.iloc[-1] and ema20.iloc[-1] > ema50.iloc[-1]:
                long_signals += 1
            elif current_price < ema20.iloc[-1] and ema20.iloc[-1] < ema50.iloc[-1]:
                short_signals += 1
            
            # RSI bazlƒ± sinyal
            if rsi < 30:
                long_signals += 1
            elif rsi > 70:
                short_signals += 1
            
            # MACD bazlƒ± sinyal
            if hist[-1] > 0 and hist[-1] > hist[-2]:
                long_signals += 1
            elif hist[-1] < 0 and hist[-1] < hist[-2]:
                short_signals += 1
            
            # Bollinger Bands bazlƒ± sinyal
            if current_price <= bb_lower[-1]:
                long_signals += 1
            elif current_price >= bb_upper[-1]:
                short_signals += 1
            
            # Stop loss seviyeleri hesaplama
            atr = self.calculate_atr(df)
            volatility = self.calculate_volatility(df)
            
            # Dinamik stop loss √ßarpanƒ±
            sl_multiplier = 1.5 + (volatility * 0.5)
            
            # Long pozisyon i√ßin stop loss
            long_sl = current_price - (atr * sl_multiplier)
            # Short pozisyon i√ßin stop loss
            short_sl = current_price + (atr * sl_multiplier)
            
            # Risk/√ñd√ºl oranƒ± hesaplama
            long_tp = current_price + (atr * sl_multiplier * 2)  # 1:2 risk/√∂d√ºl
            short_tp = current_price - (atr * sl_multiplier * 2)
            
            # Pozisyon y√∂n√º belirleme
            direction = "NEUTRAL"
            if long_signals > short_signals and long_signals >= 2:
                direction = "LONG"
            elif short_signals > long_signals and short_signals >= 2:
                direction = "SHORT"
            
            return {
                'direction': direction,
                'confidence': max(long_signals, short_signals) / 4 * 100,  # G√ºven skoru
                'current_price': current_price,
                'long_position': {
                    'stop_loss': float(long_sl),
                    'take_profit': float(long_tp),
                    'risk_reward': float((long_tp - current_price) / (current_price - long_sl))
                },
                'short_position': {
                    'stop_loss': float(short_sl),
                    'take_profit': float(short_tp),
                    'risk_reward': float((current_price - short_tp) / (short_sl - current_price))
                },
                'signals': {
                    'long_signals': long_signals,
                    'short_signals': short_signals,
                    'rsi': float(rsi),
                    'macd_hist': float(hist[-1]),
                    'bb_position': 'OVERSOLD' if current_price <= bb_lower[-1] else 'OVERBOUGHT' if current_price >= bb_upper[-1] else 'NEUTRAL'
                }
            }
            
        except Exception as e:
            self.logger.error(f"Pozisyon y√∂n√º analiz hatasƒ±: {e}")
            return {
                'direction': 'NEUTRAL',
                'confidence': 0,
                'current_price': 0,
                'long_position': {'stop_loss': 0, 'take_profit': 0, 'risk_reward': 0},
                'short_position': {'stop_loss': 0, 'take_profit': 0, 'risk_reward': 0},
                'signals': {'long_signals': 0, 'short_signals': 0, 'rsi': 0, 'macd_hist': 0, 'bb_position': 'NEUTRAL'}
            }

    async def analyze_market_parallel(self, ticker_data: list, interval: str = '4h', worker_count=None) -> list:
        """√áoklu i≈ülemci kullanarak piyasa analizi yapan yeni fonksiyon"""
        try:
            # Ba≈ülangƒ±√ß zamanƒ±nƒ± kaydet (performans √∂l√ß√ºm√º i√ßin)
            import time
            start_time = time.time()
            
            # Saya√ßlarƒ± sƒ±fƒ±rla
            self.analysis_stats = {key: 0 for key in self.analysis_stats}
            self.analysis_stats['total_coins'] = len(ticker_data)
            
            # ƒ∞≈ü√ßi sayƒ±sƒ±nƒ± belirleme (eƒüer belirtilmemi≈üse)
            if worker_count is None:
                # Sistem CPU sayƒ±sƒ±na g√∂re i≈ü√ßi sayƒ±sƒ±nƒ± belirle (CPU sayƒ±sƒ± - 1)
                worker_count = max(1, multiprocessing.cpu_count() - 1)
                # ƒ∞≈ülemci sayƒ±sƒ±nƒ± 6 ile sƒ±nƒ±rla (daha fazla i≈ülemci genellikle daha yava≈ü olabilir)
                worker_count = min(worker_count, 6)
            
            # DEBUG: ƒ∞≈ülemci bilgilerini logla
            self.logger.info(f"üîç Toplam {len(ticker_data)} coin {worker_count} i≈ülemci ile taranƒ±yor...")
            self.logger.info(f"üñ•Ô∏è  Sistem toplam CPU sayƒ±sƒ±: {multiprocessing.cpu_count()}")
            
            # T√ºm USDT √ßiftlerini al (filtreleme olmadan)
            # Blacklist tanƒ±mla - FIAT paralar ve istenmeyenler
            blacklist = [
                "EURUSDT", "GBPUSDT", "TRYUSDT", "USDTBRL", "USDTRUB", "AUDUSDT", "CADUSDT",
                "JPYUSDT", "CNHUSDT", "CHFUSDT", "AUDUSDT", "NZDSUSDT", "RUBUSDT", "BUSDUSDT",
                "TUSDUSDT", "USDCUSDT", "DAIUSDT", "FDUSDUSDT", "PYUSDUSDT", "BRLBIDR", "BRLRUB",
                "USDTBKRW", "EURUSDC", "IDRTUSDT", "UAHUSDT", "VAIUSDT", "NGNUSDT", "BIDRUSDT", "BVNDUSDT", "BKRWUSDT"
            ]
            
            # Kaldƒ±ra√ßlƒ± ve hatalƒ± tokenlar i√ßin pattern'ler
            blacklist_patterns = [
                "UP", "DOWN", "BULL", "BEAR"
            ]
            
            # T√ºm USDT √ßiftlerini al, ancak blacklist'tekileri ve blacklist pattern'leri hari√ß tut
            usdt_pairs = []
            filtered_out_count = 0
            
            for ticker in ticker_data:
                symbol = ticker['symbol']
                if symbol.endswith('USDT'):
                    # Blacklist kontrol√º
                    if symbol in blacklist:
                        filtered_out_count += 1
                        continue
                        
                    # Blacklist pattern kontrol√º
                    if any(pattern in symbol for pattern in blacklist_patterns):
                        filtered_out_count += 1
                        continue
                        
                    usdt_pairs.append(ticker)
            
            self.logger.info(f"üìä Toplam {len(usdt_pairs)} ge√ßerli USDT √ßifti bulundu (blacklist'ten {filtered_out_count} coin filtrelendi)")
            
            self.analysis_stats['valid_pairs'] = len(usdt_pairs)
            
            # √ñn filtreleme (fiyat ve hacim) - Multi-threaded yaparak hƒ±zlandƒ±rma
            filtered_pairs = []
            
            def filter_pair(ticker):
                try:
                    current_price = float(ticker['lastPrice'])
                    current_volume = float(ticker['quoteVolume'])
                    
                    if current_price < self.min_price:
                        return None
                    if current_volume < self.min_volume:
                        return None
                    return ticker
                except:
                    return None
            
            # Thread havuzu ile filtreleme - ana threadleri bloklamadan
            # √ñnceki ve sonraki i≈ülemlerle paralellik i√ßin
            import threading
            filter_results = []
            
            def filter_batch(batch):
                results = []
                for ticker in batch:
                    result = filter_pair(ticker)
                    if result:
                        results.append(result)
                filter_results.extend(results)
            
            # √áok b√ºy√ºk veri k√ºmeleri i√ßin thread'lere b√∂l
            batch_size = len(usdt_pairs) // 4  # 4 thread kullan
            batches = [usdt_pairs[i:i+batch_size] for i in range(0, len(usdt_pairs), batch_size)]
            
            threads = []
            for batch in batches:
                thread = threading.Thread(target=filter_batch, args=(batch,))
                threads.append(thread)
                thread.start()
                
            # T√ºm threadlerin tamamlanmasƒ±nƒ± bekle
            for thread in threads:
                thread.join()
                
            filtered_pairs = filter_results
            
            # Filtreleme istatistiklerini hesapla
            self.analysis_stats['price_filtered'] = 0
            self.analysis_stats['volume_filtered'] = 0
            for ticker in usdt_pairs:
                try:
                    if ticker not in filtered_pairs:
                        current_price = float(ticker['lastPrice'])
                        current_volume = float(ticker['quoteVolume'])
                        
                        if current_price < self.min_price:
                            self.analysis_stats['price_filtered'] += 1
                        elif current_volume < self.min_volume:
                            self.analysis_stats['volume_filtered'] += 1
                except Exception as e:
                    continue
            
            # ƒ∞≈ülemci ba≈üƒ±na batch hesaplama - load dengesini daha iyi saƒülamak i√ßin
            # Not: B√ºy√ºk batche d√º≈ü√ºk i≈ülemci sayƒ±sƒ± daha iyi olabilir
            if len(filtered_pairs) < worker_count * 5:
                # √áok az coin varsa worker sayƒ±sƒ±nƒ± azalt
                worker_count = max(1, len(filtered_pairs) // 3)
                self.logger.info(f"‚ö†Ô∏è  √áok az coin var. ƒ∞≈ülemci sayƒ±sƒ± {worker_count}'e d√º≈ü√ºr√ºld√º.")
            
            # ƒ∞≈ülemci ba≈üƒ±na d√º≈üen coin sayƒ±sƒ±nƒ± optimize etmek i√ßin batch size'i ayarla
            batch_size = max(1, min(10, len(filtered_pairs) // worker_count))
            batches = []
            
            # Daha akƒ±llƒ± load balancing - hacime g√∂re sƒ±rala ve daƒüƒ±t
            # B√∂ylece her i≈ülemciye hem y√ºksek hem d√º≈ü√ºk hacimli coinler d√º≈üer
            filtered_pairs.sort(key=lambda x: float(x['quoteVolume']), reverse=True)
            
            # Hacim sƒ±ralƒ± listeyi i≈ülemcilere daƒüƒ±t
            for i in range(worker_count):
                batch = filtered_pairs[i::worker_count]  # Her i≈ülemciye bir coin atla
                if batch:  # Bo≈ü batch olu≈üturma
                    batches.append(batch)
            
            if not filtered_pairs:
                self.logger.warning("Filtreleme sonrasƒ± coin kalmadƒ±!")
                return []
                
            self.logger.info(f"üìå Filtreleme sonrasƒ± {len(filtered_pairs)} coin analiz edilecek")
            self.logger.info(f"üõ†Ô∏è  {len(batches)} batch olu≈üturuldu (i≈ülemci ba≈üƒ±na ~{len(filtered_pairs)/max(1, len(batches)):.1f} coin)")
            
            # Analiz i≈ülemini paralel olarak √ßalƒ±≈ütƒ±r
            loop = asyncio.get_event_loop()
            
            opportunities = []
            with concurrent.futures.ProcessPoolExecutor(max_workers=worker_count) as executor:
                # Her batch i√ßin _analyze_batch fonksiyonunu √ßaƒüƒ±r
                analyze_batch_partial = partial(self._analyze_batch, interval=interval)
                
                # Senkronize edilerek yapƒ±lan RPC √ßaƒürƒ±sƒ±nƒ± √∂l√ß
                batch_start_time = time.time()
                batch_results = await loop.run_in_executor(
                    None,
                    lambda: list(executor.map(analyze_batch_partial, batches))
                )
                batch_end_time = time.time()
                batch_elapsed = batch_end_time - batch_start_time
                
                # ƒ∞≈ülemci ba≈üƒ±na s√ºreyi hesapla
                self.logger.info(f"‚è±Ô∏è  Paralel i≈ülemler {batch_elapsed:.2f} saniyede tamamlandƒ± (i≈ülemci ba≈üƒ±na ~{batch_elapsed/max(1, len(batches)):.2f}s)")
                
                # DEBUG: i≈ülemci ba≈üƒ±na analiz edilecek coin sayƒ±sƒ±nƒ± logla
                for i, batch in enumerate(batches):
                    self.logger.debug(f"Worker {i+1}: {len(batch)} coin analiz edilecek")
                
                # Sonu√ßlarƒ± birle≈ütir
                for i, batch_result in enumerate(batch_results):
                    # DEBUG: Her i≈ülemcinin sonu√ßlarƒ±nƒ± logla
                    self.logger.debug(f"Worker {i+1} Sonucu: {len(batch_result['opportunities'])} fƒ±rsat bulundu, " + 
                                 f"Ba≈üarƒ±lƒ±: {batch_result['stats']['success']}, " + 
                                 f"Ba≈üarƒ±sƒ±z: {batch_result['stats']['failed']}")
                    
                    opportunities.extend(batch_result['opportunities'])
                    
                    # ƒ∞statistikleri g√ºncelle
                    self.analysis_stats['analysis_success'] += batch_result['stats']['success']
                    self.analysis_stats['analysis_failed'] += batch_result['stats']['failed']
                
            # S√ºre hesaplama
            end_time = time.time()
            elapsed_time = end_time - start_time
            
            # Analiz istatistiklerini logla
            self.logger.info("\nüìä TARAMA ƒ∞STATƒ∞STƒ∞KLERƒ∞:")
            self.logger.info(f"üìå Toplam Coin: {self.analysis_stats['total_coins']}")
            self.logger.info(f"‚úÖ Ge√ßerli USDT √áiftleri: {self.analysis_stats['valid_pairs']}")
            self.logger.info(f"üí∞ Fiyat Filtresi: {self.analysis_stats['price_filtered']}")
            self.logger.info(f"üìä Hacim Filtresi: {self.analysis_stats['volume_filtered']}")
            self.logger.info(f"‚ú® Ba≈üarƒ±lƒ± Analiz: {self.analysis_stats['analysis_success']}")
            self.logger.info(f"‚ùå Ba≈üarƒ±sƒ±z Analiz: {self.analysis_stats['analysis_failed']}")
            self.logger.info(f"‚è±Ô∏è Toplam S√ºre: {elapsed_time:.2f} saniye ({worker_count} i≈ülemci ile)")
            
            # Fƒ±rsatlarƒ± puana g√∂re sƒ±rala
            opportunities.sort(key=lambda x: x['opportunity_score'], reverse=True)
            
            if opportunities:
                self.logger.info(f"üéØ Bulunan Fƒ±rsat Sayƒ±sƒ±: {len(opportunities)}")
            else:
                self.logger.info("‚ùå Fƒ±rsat bulunamadƒ±")
            
            return opportunities[:10]  # En iyi 10 fƒ±rsatƒ± d√∂nd√ºr
            
        except Exception as e:
            self.logger.error(f"Parallel market analysis error: {str(e)}")
            return []
        finally:
            try:
                await self.exchange.close()
            except:
                pass

    def _analyze_batch(self, batch: list, interval: str = '4h'):
        """Bir batch i√ßindeki coinleri seri olarak analiz et - Process havuzunda √ßalƒ±≈üƒ±r"""
        import ccxt  # Yeni process i√ßin gereken importlar
        import pandas as pd
        import numpy as np
        import concurrent.futures
        import time
        
        start_time = time.time()
        opportunities = []
        stats = {'success': 0, 'failed': 0}
        
        # API √ßaƒürƒ± sayƒ±sƒ±nƒ± azaltmak i√ßin bir exchange nesnesi olu≈ütur
        exchange = ccxt.binance({
            'enableRateLimit': True,
            'options': {'defaultType': 'spot'}
        })
        
        # E≈ü zamanlƒ± i≈ülem
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as thread_executor:
            # API √ßaƒürƒ±larƒ±nƒ± e≈ü zamanlƒ± yap
            future_to_symbol = {}
            
            for ticker in batch:
                symbol = ticker['symbol']
                future = thread_executor.submit(
                    self._analyze_single_coin_data, 
                    exchange, 
                    symbol, 
                    interval, 
                    float(ticker['lastPrice']),
                    float(ticker['quoteVolume'])
                )
                future_to_symbol[future] = symbol
                
            # T√ºm sonu√ßlarƒ± topla
            for future in concurrent.futures.as_completed(future_to_symbol):
                symbol = future_to_symbol[future]
                try:
                    result = future.result()
                    if result:
                        opportunities.append(result)
                        stats['success'] += 1
                    else:
                        stats['failed'] += 1
                except Exception as e:
                    stats['failed'] += 1
        
        end_time = time.time()
        elapsed = end_time - start_time
        
        # Peformanns debug bilgisi
        print(f"Batch of {len(batch)} coins processed in {elapsed:.2f}s - Success: {stats['success']}, Failed: {stats['failed']}")
        
        return {'opportunities': opportunities, 'stats': stats}
    
    def _analyze_single_coin_data(self, exchange, symbol, interval, current_price, current_volume):
        """Tek bir coin i√ßin analiz i≈ülemi yap - Thread i√ßinde √ßalƒ±≈üƒ±r"""
        try:
            # OHLCV verileri al
            try:
                ohlcv = exchange.fetch_ohlcv(symbol, interval, limit=50)
                if not ohlcv or len(ohlcv) < 30:
                    return None
                
                # DataFrame olu≈ütur (geli≈ümi≈ü stop/loss hesaplamasƒ± i√ßin)
                df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                
            except Exception as e:
                return None
            
            # Temel hesaplamalar
            closes = np.array([float(candle[4]) for candle in ohlcv])
            volumes = np.array([float(candle[5]) for candle in ohlcv])
            
            # Teknik indikat√∂rler
            indicators = self._calculate_technical_indicators(closes, volumes)
            
            # Hacim analizi
            volume_analysis = self._analyze_volume(current_volume, volumes)
            
            # Fƒ±rsat puanƒ± hesapla
            opportunity_score = self._calculate_opportunity_score(
                indicators['rsi'][-1],
                indicators['macd_hist'][-1],
                volume_analysis['volume_surge'],
                indicators['trend'],
                current_volume,
                volume_analysis['avg_volume']
            )
            
            if opportunity_score < 40:
                return None
            
            # Pozisyon √∂nerisi
            position_rec = self._analyze_position_recommendation(
                indicators['rsi'][-1], 
                indicators['macd_hist'][-1],
                indicators['ema20'][-1],
                indicators['ema50'][-1],
                indicators['bb_upper'],
                indicators['bb_lower'],
                current_price,
                opportunity_score,
                volume_analysis['volume_surge']
            )
            
            # Geli≈ümi≈ü stop/loss ve take profit hesapla
            risk_management = None
            actual_position_type = "LONG" if "LONG" in position_rec['position'] else "SHORT" if "SHORT" in position_rec['position'] else "NEUTRAL"
            
            if actual_position_type in ["LONG", "SHORT"]:
                risk_management = self.calculate_advanced_stoploss(df, current_price, actual_position_type)
            
            # Sonu√ß olu≈ütur
            result = {
                'symbol': symbol,
                'price': current_price,
                'volume': current_volume,
                'rsi': float(indicators['rsi'][-1]),
                'macd': float(indicators['macd_hist'][-1]),
                'trend': indicators['trend'],
                'volume_surge': volume_analysis['volume_surge'],
                'opportunity_score': float(opportunity_score),
                'signal': self._determine_signal(opportunity_score, indicators['rsi'][-1], indicators['trend']),
                'position_recommendation': position_rec['position'],
                'position_confidence': position_rec['confidence'],
                'recommended_leverage': position_rec['leverage'],
                'risk_level': position_rec['risk_level'],
                'analysis_reasons': position_rec['reasons'],
                'score': position_rec['score'],
                'ema20': float(indicators['ema20'][-1]),
                'ema50': float(indicators['ema50'][-1]),
                'bb_upper': float(indicators['bb_upper']),
                'bb_middle': float(indicators['bb_middle']),
                'bb_lower': float(indicators['bb_lower'])
            }
            
            # Risk y√∂netimi bilgilerini ekle
            if risk_management:
                result.update({
                    'advanced_stoploss': risk_management['stoploss'],
                    'take_profit_levels': risk_management['take_profits'],
                    'trailing_activation': risk_management['trailing_activation'],
                    'trailing_step': risk_management['trailing_step'],
                    'risk_percent': risk_management['risk_percent'],
                    'atr': risk_management['atr']
                })
            
            return result
            
        except Exception as e:
            return None

    def _calculate_technical_indicators(self, closes: np.ndarray, volumes: np.ndarray) -> Dict:
        """T√ºm teknik indikat√∂rleri tek bir fonksiyonda hesapla"""
        try:
            # RSI
            rsi = self._calculate_rsi_quick(closes)
            
            # MACD
            macd, signal, hist = self._calculate_macd_quick(closes)
            
            # Bollinger Bands
            bb_upper, bb_middle, bb_lower = self._calculate_bollinger_bands_quick(closes)
            
            # EMA
            ema20 = self._calculate_ema_quick(closes, 20)
            ema50 = self._calculate_ema_quick(closes, 50)
            
            # Trend
            trend = "YUKARI" if ema20[-1] > ema50[-1] else "A≈ûAƒûI"
            
            return {
                'rsi': rsi,
                'macd': macd,
                'macd_signal': signal,
                'macd_hist': hist,
                'bb_upper': bb_upper,
                'bb_middle': bb_middle,
                'bb_lower': bb_lower,
                'ema20': ema20,
                'ema50': ema50,
                'trend': trend
            }
        except Exception as e:
            self.logger.error(f"Teknik indikat√∂r hesaplama hatasƒ±: {e}")
            return None

    def _analyze_volume(self, current_volume: float, volumes: np.ndarray) -> Dict:
        """Hacim analizini tek bir fonksiyonda yap"""
        try:
            avg_volume = np.mean(volumes[-10:])
            volume_surge = current_volume > (avg_volume * 1.2)
            
            return {
                'avg_volume': avg_volume,
                'volume_surge': volume_surge,
                'volume_ratio': current_volume / avg_volume if avg_volume > 0 else 1
            }
        except Exception as e:
            self.logger.error(f"Hacim analizi hatasƒ±: {e}")
            return {
                'avg_volume': 0,
                'volume_surge': False,
                'volume_ratio': 1
            }

    def _calculate_rsi_quick(self, prices, period=14):
        # Orijinal metot ile aynƒ± ama optimize edildi
        # Son verileri kullanarak hƒ±zlƒ± hesaplama
        deltas = np.diff(prices[-period-10:])  # Son periyot+10 veri al
        seed = deltas[:period+1]
        up = seed[seed >= 0].sum()/period
        down = -seed[seed < 0].sum()/period
        rs = up/down if down != 0 else 0
        rsi = np.zeros(len(prices[-period-10:]))
        rsi[:period] = 100. - 100./(1.+rs)

        for i in range(period, len(prices[-period-10:])):
            delta = deltas[i-1]
            if delta > 0:
                upval = delta
                downval = 0.
            else:
                upval = 0.
                downval = -delta

            up = (up*(period-1) + upval)/period
            down = (down*(period-1) + downval)/period
            rs = up/down if down != 0 else 0
            rsi[i] = 100. - 100./(1.+rs)

        return rsi[-5:]

    def _calculate_macd_quick(self, prices):
        # Karsƒ±la≈ütƒ±rma i√ßin son verileri al
        prices_subset = prices[-40:]  # Son 40 veri yeterli
        exp1 = pd.Series(prices_subset).ewm(span=12, adjust=False).mean()
        exp2 = pd.Series(prices_subset).ewm(span=26, adjust=False).mean()
        macd = exp1 - exp2
        signal = macd.ewm(span=9, adjust=False).mean()
        hist = macd - signal
        return macd.values, signal.values, hist.values

    def _calculate_bollinger_bands_quick(self, prices, period=20):
        # Son verileri kullanarak BB hesapla
        prices_subset = prices[-period-5:]  # Son period+5 veri
        sma = np.mean(prices_subset[-period:])
        std = np.std(prices_subset[-period:])
        upper = sma + (std * 2)
        lower = sma - (std * 2)
        return upper, sma, lower

    def _calculate_ema_quick(self, prices, period):
        # Son verileri kullanarak EMA hesapla
        prices_subset = prices[-period-15:]  # Son period+15 veri
        return pd.Series(prices_subset).ewm(span=period, adjust=False).mean().values

    def _calculate_opportunity_score_quick(self, rsi, macd, volume_surge, trend,
                                   current_volume, avg_volume):
        # Basitle≈ütirilmi≈ü fƒ±rsat puanƒ± hesaplama
        score = 0
        
        # RSI bazlƒ± puan (0-30)
        if rsi < 30:  # A≈üƒ±rƒ± satƒ±m
            score += 30
        elif rsi > 70:  # A≈üƒ±rƒ± alƒ±m
            score += 10
        else:
            score += 20
            
        # MACD bazlƒ± puan (0-20)
        if macd > 0:
            score += 20
        elif macd < 0:
            score += 5
        
        # Hacim bazlƒ± puan (0-30)
        if volume_surge:
            score += 30
        else:
            score += 20 if current_volume > avg_volume else 10
            
        # Trend bazlƒ± puan (0-20)
        if trend == "YUKARI":
            score += 20
        else:
            score += 10
            
        return min(100, score)

    def _analyze_position_recommendation_quick(self, 
                                       rsi, 
                                       macd, 
                                       ema20,
                                       ema50,
                                       bb_upper,
                                       bb_lower,
                                       current_price,
                                       opportunity_score,
                                       volume_surge):
        # Basitle≈ütirilmi≈ü pozisyon √∂nerisi
        is_bullish = (ema20 > ema50) or (rsi < 40) or (macd > 0)
        is_bearish = (ema20 < ema50) or (rsi > 60) or (macd < 0)
        
        if rsi < 30 and current_price < (bb_lower * 1.05):
            position_type = "STRONG_LONG"
            confidence = 3
            reasons = ["RSI a≈üƒ±rƒ± satƒ±m b√∂lgesinde", "Fiyat BB alt bandƒ±nƒ±n altƒ±nda"]
        elif rsi > 70 and current_price > (bb_upper * 0.95):
            position_type = "STRONG_SHORT"
            confidence = 3
            reasons = ["RSI a≈üƒ±rƒ± alƒ±m b√∂lgesinde", "Fiyat BB √ºst bandƒ±nƒ±n √ºst√ºnde"]
        elif is_bullish and not is_bearish:
            position_type = "LONG"
            confidence = 2
            reasons = ["Eƒüilim y√ºkseliyor"]
        elif is_bearish and not is_bullish:
            position_type = "SHORT"
            confidence = 2
            reasons = ["Eƒüilim d√º≈ü√ºyor"]
        else:
            position_type = "NEUTRAL"
            confidence = 1
            reasons = ["Net bir eƒüilim yok"]
            
        # Kaldƒ±ra√ß √∂nerisi
        leverage = 2  # Varsayƒ±lan d√º≈ü√ºk kaldƒ±ra√ß
        if opportunity_score > 80:
            leverage = 10
        elif opportunity_score > 60:
            leverage = 5
            
        return {
            'position': position_type,
            'confidence': confidence,
            'leverage': leverage,
            'reasons': reasons,
            'risk_level': "Y√úKSEK" if leverage > 5 else "ORTA",
            'score': opportunity_score
        }

    def _generate_signal(self, rsi: float, macd: float, price: float, bb_upper: float, bb_lower: float) -> str:
        """Sinyal √ºret"""
        try:
            if any(v is None for v in [rsi, macd, price, bb_upper, bb_lower]):
                return "VERƒ∞ YOK"
            
            # BB pozisyonu hesapla (0-100 arasƒ±)
            bb_range = bb_upper - bb_lower
            if bb_range > 0:
                bb_position = (price - bb_lower) / bb_range * 100
            else:
                bb_position = 50
            
            # 15 dakikalƒ±k i≈ülemler i√ßin SHORT sinyallerini daha agresif deƒüerlendir
            if rsi > 60 and price >= bb_upper * 0.95:
                return "G√ú√áL√ú SHORT"
            elif rsi > 55 and macd < 0:
                return "SHORT"
            elif rsi < 30 and price <= bb_lower * 1.05:
                return "G√ú√áL√ú LONG"
            elif rsi < 40 and macd > 0:
                return "LONG"
            
            # BB pozisyonuna g√∂re ek kontrol
            if bb_position > 80:
                return "SHORT"
            elif bb_position < 20:
                return "LONG"
            
            return "BEKLE"
            
        except Exception as e:
            self.logger.error(f"Sinyal √ºretme hatasƒ±: {e}")
            return "HATA" 

    def calculate_advanced_stoploss(self, df: pd.DataFrame, current_price: float, position_type: str) -> Dict:
        """Geli≈ümi≈ü stop loss hesaplama"""
        try:
            # ATR hesapla
            atr = self.calculate_atr(df)
            volatility = self.calculate_volatility(df)
            
            # Stop loss √ßarpanƒ± (volatiliteye g√∂re ayarlanƒ±r)
            sl_multiplier = 1.5 + (volatility * 0.5)
            
            # Stop loss ve take profit seviyeleri
            if position_type == "LONG":
                stop_loss = current_price - (atr * sl_multiplier)
                take_profit = current_price + (atr * sl_multiplier * 2)  # 1:2 risk/√∂d√ºl
                trailing_activation = current_price + (atr * sl_multiplier)
            else:  # SHORT
                stop_loss = current_price + (atr * sl_multiplier)
                take_profit = current_price - (atr * sl_multiplier * 2)
                trailing_activation = current_price - (atr * sl_multiplier)
            
            # Risk y√ºzdesi
            risk_percent = abs(current_price - stop_loss) / current_price * 100
            
            return {
                'stoploss': float(stop_loss),
                'take_profits': [float(take_profit)],
                'trailing_activation': float(trailing_activation),
                'trailing_step': float(atr * 0.3),
                'risk_percent': float(risk_percent),
                'atr': float(atr)
            }
            
        except Exception as e:
            self.logger.error(f"Stop loss hesaplama hatasƒ±: {e}")
            return None 

    async def generate_chart(self, symbol: str, timeframe: str = "4h") -> BytesIO:
        """
        Verilen sembol i√ßin teknik analiz grafiƒüi olu≈üturur
        """
        try:
            # OHLCV verilerini al
            ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=100)
            
            if not ohlcv or len(ohlcv) < 20:
                self.logger.error(f"{symbol} i√ßin yeterli veri bulunamadƒ±")
                return None
                
            # DataFrame olu≈ütur
            df = pd.DataFrame(
                ohlcv,
                columns=['timestamp', 'open', 'high', 'low', 'close', 'volume']
            )
            
            # Timestamp'i datetime'a √ßevir
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)
            
            # Teknik indikat√∂rleri hesapla
            ema20 = EMAIndicator(close=df['close'], window=20)
            ema50 = EMAIndicator(close=df['close'], window=50)
            ema200 = EMAIndicator(close=df['close'], window=200)
            df['EMA20'] = ema20.ema_indicator()
            df['EMA50'] = ema50.ema_indicator()
            df['EMA200'] = ema200.ema_indicator()
            
            # RSI
            rsi = RSIIndicator(close=df['close'])
            df['RSI'] = rsi.rsi()
            
            # Bollinger Bands
            bb = BollingerBands(close=df['close'])
            df['BB_UPPER'] = bb.bollinger_hband()
            df['BB_MIDDLE'] = bb.bollinger_mavg()
            df['BB_LOWER'] = bb.bollinger_lband()
            
            # MACD
            exp1 = df['close'].ewm(span=12, adjust=False).mean()
            exp2 = df['close'].ewm(span=26, adjust=False).mean()
            df['MACD'] = exp1 - exp2
            df['MACD_SIGNAL'] = df['MACD'].ewm(span=9, adjust=False).mean()
            
            # Grafik ayarlarƒ±
            mc = mpf.make_marketcolors(
                up='green',
                down='red',
                edge='inherit',
                wick='inherit',
                volume='in',
                ohlc='inherit'
            )
            
            s = mpf.make_mpf_style(
                marketcolors=mc,
                gridstyle='dotted',
                y_on_right=True
            )
            
            # Grafik panellerini ayarla
            fig = mpf.figure(figsize=(12, 8), style=s)
            
            # Panel boyutlarƒ±nƒ± ayarla (y√ºkseklik oranlarƒ±)
            gs = fig.add_gridspec(6, 1)
            
            # Ana grafik paneli
            ax1 = fig.add_subplot(gs[0:3, :])
            # Hacim paneli
            ax2 = fig.add_subplot(gs[3:5, :], sharex=ax1)
            # RSI paneli
            ax3 = fig.add_subplot(gs[5, :], sharex=ax1)
            
            # Ana mum grafiƒüi
            mpf.plot(
                df,
                type='candle',
                style=s,
                ax=ax1,
                volume=ax2,  # Hacim grafiƒüi i√ßin ax2'yi kullan
                warn_too_much_data=10000
            )
            
            # EMA'larƒ± ekle
            ax1.plot(df.index, df['EMA20'], label='EMA20', color='blue', alpha=0.7)
            ax1.plot(df.index, df['EMA50'], label='EMA50', color='orange', alpha=0.7)
            ax1.plot(df.index, df['EMA200'], label='EMA200', color='red', alpha=0.7)
            
            # Bollinger Bands
            ax1.plot(df.index, df['BB_UPPER'], '--', label='BB Upper', color='gray', alpha=0.5)
            ax1.plot(df.index, df['BB_MIDDLE'], '--', label='BB Middle', color='gray', alpha=0.5)
            ax1.plot(df.index, df['BB_LOWER'], '--', label='BB Lower', color='gray', alpha=0.5)
            
            # RSI grafiƒüi
            ax3.plot(df.index, df['RSI'], label='RSI', color='purple')
            ax3.axhline(y=70, color='r', linestyle='--', alpha=0.3)
            ax3.axhline(y=30, color='g', linestyle='--', alpha=0.3)
            ax3.fill_between(df.index, df['RSI'], 70, where=(df['RSI'] >= 70), color='red', alpha=0.3)
            ax3.fill_between(df.index, df['RSI'], 30, where=(df['RSI'] <= 30), color='green', alpha=0.3)
            
            # Grafik ba≈ülƒ±ƒüƒ± ve etiketler
            ax1.set_title(f'{symbol} {timeframe} Grafiƒüi')
            ax1.legend(loc='upper left')
            ax2.set_ylabel('Hacim')
            ax3.set_ylabel('RSI')
            
            # Y ekseni aralƒ±klarƒ±nƒ± ayarla
            ax3.set_ylim(0, 100)
            
            # Grafik d√ºzenlemeleri
            plt.tight_layout()
            
            # Grafiƒüi BytesIO'ya kaydet
            buf = BytesIO()
            plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
            buf.seek(0)
            plt.close()
            
            return buf
            
        except Exception as e:
            self.logger.error(f"Grafik olu≈üturma hatasƒ± ({symbol}): {e}")
            return None

    def calculate_rsi(self, prices, period=14):
        """RSI hesapla"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        return 100 - (100 / (1 + rs))
        
    def calculate_macd(self, prices, fast=12, slow=26, signal=9):
        """MACD hesapla"""
        exp1 = prices.ewm(span=fast, adjust=False).mean()
        exp2 = prices.ewm(span=slow, adjust=False).mean()
        macd = exp1 - exp2
        signal_line = macd.ewm(span=signal, adjust=False).mean()
        histogram = macd - signal_line
        return macd, signal_line, histogram
        
    def calculate_bollinger_bands(self, prices, period=20, std=2):
        """Bollinger Bands hesapla"""
        middle = prices.rolling(window=period).mean()
        std_dev = prices.rolling(window=period).std()
        upper = middle + (std_dev * std)
        lower = middle - (std_dev * std)
        return upper, middle, lower

    async def analyze_opportunity(self, symbol: str, timeframe: str = "4h") -> dict:
        """
        Belirli bir sembol i√ßin fƒ±rsat analizi yapar
        """
        try:
            # Kline verilerini al
            klines = await self.client.get_klines(symbol, interval=timeframe, limit=100)
            if not klines:
                return None
                
            # DataFrame'e √ßevir - t√ºm s√ºtunlarƒ± belirterek
            df = pd.DataFrame(klines, columns=[
                'timestamp', 'open', 'high', 'low', 'close', 'volume',
                'close_time', 'quote_volume', 'trades', 'buy_base_volume',
                'buy_quote_volume', 'ignore'
            ])
            
            # Sadece gerekli s√ºtunlarƒ± se√ß
            df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]
            
            # Veri tiplerini d√∂n√º≈üt√ºr
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            
            # Teknik g√∂stergeleri hesapla
            rsi = self.calculate_rsi(df['close'])
            macd, signal, hist = self.calculate_macd(df['close'])
            bb_upper, bb_middle, bb_lower = self.calculate_bollinger_bands(df['close'])
            
            # Son deƒüerleri al
            current_price = float(df['close'].iloc[-1])
            current_rsi = float(rsi.iloc[-1])
            current_macd = float(macd.iloc[-1])
            current_signal = float(signal.iloc[-1])
            current_hist = float(hist.iloc[-1])
            
            # Trend analizi
            trend = "NEUTRAL"
            trend_strength = 0.0
            
            if current_rsi > 70:
                trend = "BEARISH"
                trend_strength = min((current_rsi - 70) / 30, 1.0)
            elif current_rsi < 30:
                trend = "BULLISH"
                trend_strength = min((30 - current_rsi) / 30, 1.0)
                
            if current_macd > current_signal:
                if trend == "BULLISH":
                    trend_strength += 0.2
                elif trend == "NEUTRAL":
                    trend = "BULLISH"
                    trend_strength = 0.3
            elif current_macd < current_signal:
                if trend == "BEARISH":
                    trend_strength += 0.2
                elif trend == "NEUTRAL":
                    trend = "BEARISH"
                    trend_strength = 0.3
                    
            # Sonu√ßlarƒ± d√∂nd√ºr
            return {
                "symbol": symbol,
                "timeframe": timeframe,
                "current_price": current_price,
                "rsi": current_rsi,
                "macd": current_macd,
                "macd_signal": current_signal,
                "macd_hist": current_hist,
                "trend": trend,
                "trend_strength": trend_strength,
                "bb_upper": float(bb_upper.iloc[-1]),
                "bb_middle": float(bb_middle.iloc[-1]),
                "bb_lower": float(bb_lower.iloc[-1])
            }
            
        except Exception as e:
            self.logger.error(f"Fƒ±rsat analizi hatasƒ± ({symbol}): {str(e)}")
            return None